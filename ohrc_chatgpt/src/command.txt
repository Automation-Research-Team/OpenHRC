Here is my roscpp header file to control robot. please make a new full class file, named "MoveEndEffector," referring this Interface class achieving the following rules.

 -  Move robot end effector position to draw a square with a side of 10 cm in x-z plane. Keep the initial orientation.  
 - The initial end-effector position can be got by "controller->getT_init()" that return in form of Eigen::Affine3d. This position is regarded to be start position, bottom back edge. This function should be called at first time calling uptateTargetPose().
 - After finishing above motions, wait 3.0 seconds and print "loop finished" on the terminal. Then repeat these process for unlimited number of times.
 - Each movement should be run for 3 seconds.
 - In updateTargetPose(), you need to find appropriate pose and twist generating above motions, not zeros.
 - At first time the node call updateTargetPose(), please call controller->startOperation().
 - In the code, please tf::transformKDLToEigen() or tf::transformEigenToKDL().


``` ohrc_control/interface.hpp
enum class TaskState {
  Initial,
  OnGoing,
  Success,
  Fail,
};
class Interface {
protected:
  ros::NodeHandle n;
  double dt;

  std::shared_ptr<CartController> controller;

  ros::TransportHints th = ros::TransportHints().tcpNoDelay(true);

  TaskState taskState = TaskState::Initial;

  std::string targetName;
  double targetDistance = 0.0;

public:
  Interface(std::shared_ptr<CartController> controller) : n("~") {
    this->controller = controller;
    dt = controller->dt;
  };

// this update is called every this->dt [s]. 
// Both  pose and twist are required
  virtual void updateTargetPose(KDL::Frame& pose, KDL::Twist& twist){};
  virtual void initInterface(){};
  virtual void resetInterface(){};

  int curTargetId = 0, nCompletedTask = 0;
  bool blocked = false;

  std::string getTargetName() {
    return this->targetName;
  }

  double getTargetDistance() {
    return this->targetDistance;
  }

  TaskState getTaskState() {
    return this->taskState;
  }
};
```
